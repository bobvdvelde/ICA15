{
    "contents" : "#' Create an adjacency graph from a document term matrix\n#' \n#' @param dtm a document term matrix, either or not in the dtm format from the `tm` package\n#' @param measure the measure to calcualte adjacency. Currently supports cosine and conditional probability\n#' @return A graph in the Igraph format in which edges represent the adjacency of terms\n#' @export\ncooccurenceNetwork <- function(dtm, measure='cooccurence'){\n  if('DocumentTermMatrix' %in% class(dtm)) dtm = dtmToSparseMatrix(dtm)\n  dtm = as(dtm, 'dgCMatrix')\n  if(measure == 'cosine') {\n    mat = getCosine(dtm)\n    Matrix::diag(mat) = 0 # ignore loops\n    g = graph.adjacency(mat, mode='upper', diag=F, weighted=T)\n  }\n  if(measure == 'cooccurence') {\n    mat = getCoOccurence(dtm)\n    g = graph.adjacency(mat, mode='upper', diag=F, weighted=T)\n  }\n  if(measure == 'conprob') {\n    mat = getConditionalProbability(dtm)\n    g = graph.adjacency(mat, mode='directed', diag=F, weighted=T)\n  }\n  V(g)$freq = col_sums(dtm)\n  #edgelist = Matrix::which(mat>0, arr.ind=T)\n  #edgelist = data.frame(x=rownames(mat)[edgelist[,1]], y=colnames(mat)[edgelist[,2]], weight=mat@x[mat@x>0])\n  #edgelist\n  g\n}\n\ndtmToSparseMatrix <- function(dtm){\n  sm = spMatrix(nrow(dtm), ncol(dtm), dtm$i, dtm$j, dtm$v)\n  rownames(sm) = rownames(dtm)\n  colnames(sm) = colnames(dtm)\n  sm\n}\n\ngetCoOccurence <- function(m1, m2=m1){\n  m1@x[m1@x > 0] = 1\n  m2@x[m2@x > 0] = 1\n  mat = Matrix::crossprod(m1,m2) \n  mat[is.na(mat)] = 0\n  mat\n}\n\ngetConditionalProbability <- function(m1, m2=m1){\n  m1@x[m1@x > 0] = 1\n  m2@x[m2@x > 0] = 1\n  mat = Matrix::crossprod(m1,m2)/Matrix::colSums(m1) \n  mat[is.na(mat)] = 0\n  mat\n}\n\ngetCosine <- function(m1, m2=m1){\n  norm.x = sqrt(Matrix::colSums(m1^2))\n  norm.y = sqrt(Matrix::colSums(m2^2))\n  mat = Matrix::crossprod(m1,m2)\n  mat = mat / Matrix::tcrossprod(norm.x, norm.y)\n  mat[is.na(mat)] = 0\n  mat\n}\n\n##### windowed adjacency functions #####\n\nstretchLocation <- function(location, context, window.size){\n  ## (location and context need to be sorted on order(context,location))\n  newcontext = which(!duplicated(context))\n  context.max = location[newcontext-1] + (window.size*2)\n  multiplier_scores = cumsum(c(0,context.max))\n  multiplier_vector = rep(NA, length(context))\n  multiplier_vector[newcontext] = multiplier_scores\n  multiplier_vector = na.locf(multiplier_vector)\n  return(location + multiplier_vector)\n}\n\nlocationMatrix <- function(i, j, shifts=0, count.once=T){\n  mat = spMatrix(max(i), max(j))\n  for(shift in shifts){\n    i_shift = i + shift\n    select = i_shift > 0 & i_shift <= max(i)\n    mat = mat + spMatrix(nrow=max(i), ncol=max(j), i=i_shift[select], j=j[select], rep(1, sum(select))) \n  }\n  mat = mat[i,]\n  mat = as(mat, 'dgCMatrix')\n  if(count.once) mat@x[mat@x>0] = 1\n  mat\n}\n\n#' Gives the window in which a term occured in a matrix.\n#' \n#' This function returns the occurence of words (location.matrix) and the window of occurence (window.matrix). This format enables the co-occurence of words within sliding windows (i.e. word distance) to be calculated by multiplying location.matrix with window.matrix. \n#' \n#' @param location An integer vector giving the position of terms in a given context (e.g., document, paragraph, sentence) \n#' @param term A character vector giving the terms\n#' @param context A vector giving the context in which terms occur (e.g., document, paragraph, sentence)\n#' @param window.size The distance within which words should occur from each other to be counted as a co-occurence.\n#' @param two.sided Logical. If false, it is only counted how often a word occured `after` another word within the given window size\n#' @return A list with two matrices. location.mat gives the specific location of a term, and window.mat gives the window in which each word occured. The rows represent the location of a term, and matches the input of this function (location, term and context). The columns represents terms.\n#' @export\nwordWindowOccurence <- function(location, term, context, window.size=3, two.sided=T){\n  nas = is.na(term)\n  if (any(nas)) {\n    term = term[!nas]\n    location = location[!nas]\n    context = context[!nas]\n  }\n  \n  ord = order(context, location)\n  location = location[ord]\n  term = term[ord]\n  context = context[ord]\n  \n  location = stretchLocation(location,context,window.size=window.size)\n  shifts = if(two.sided) -window.size:window.size else 0:window.size\n  terms = unique(term)\n  term_index = match(term, terms)\n  \n  location.mat = locationMatrix(location, term_index, 0)\n  window.mat = locationMatrix(location, term_index, shifts)\n  \n  colnames(location.mat) = colnames(window.mat) = terms\n  rownames(location.mat) = rownames(window.mat) = context\n  \n  \n  list(location.mat=location.mat, window.mat=window.mat)\n  \n  #calculateAdjacency(location.mat, window.mat)\n}\n\n#' A sliding window approach to calculate the co-occurence of words\n#' \n#' @param location An integer vector giving the position of terms in a given context (e.g., document, paragraph, sentence) \n#' @param term A character vector giving the terms\n#' @param context A vector giving the context in which terms occur (e.g., document, paragraph, sentence)\n#' @param window.size The distance within which words should occur from each other to be counted as a co-occurence.\n#' @param output.per.context Logical. If True, co-occurences are reported per context (beware that this takes longer and can lead to huge output)\n#' @param two.sided Logical. If false, it is only counted how often a word occured `after` another word within the given window size\n#' @return An edgelist (data.frame) with columns x, y and weight, in which weight represents the number of times y occured within a [window.size] word distance from x. If output.per.context is True, co-occurences are reported per context, and the edgelist has an additional context column.\n#' @export\nwindowedCoOccurenceNetwork <- function(location, term, context, window.size=10, output.per.context=F, two.sided=T){\n  if(min(location) == 0) location = location + 1 # if indexing starts at 0, set to 1\n  mat = wordWindowOccurence(location, term, context, window.size, two.sided)\n  if(output.per.context) {\n    calculateAdjacencyPerContext(mat$location.mat, mat$window.mat)\n  } else {\n    calculateAdjacency(mat$location.mat, mat$window.mat)\n  }\n}\n\ncalculateAdjacency <- function(location.mat, window.mat){\n  adj = Matrix::crossprod(location.mat, window.mat)\n  g = graph.adjacency(adj, mode='directed', weighted=T, diag=F)\n  V(g)$freq = col_sums(location.mat)\n  g\n  #edgelist = Matrix::which(adj>0, arr.ind=T)\n  #edgelist = data.frame(x=rownames(adj)[edgelist[,1]], y=colnames(adj)[edgelist[,2]], weight=adj@x[adj@x>0])\n  #edgelist\n}\n\naggCoOc <- function(x, location.mat, window.mat){\n  cooc = location.mat[,x] & window.mat\n  cooc = as(cooc, 'lgTMatrix')\n  cooc = data.frame(x=x, y=cooc@j+1, context=cooc@i+1, weight=cooc@x)\n  cooc = cooc[!cooc$x == cooc$y,]\n  ddply(cooc, .(x,y,context), summarize, weight=sum(weight))\n}\n\ncalculateAdjacencyPerContext <- function(location.mat, window.mat) {\n  adj = ldply(1:ncol(location.mat), function(x) aggCoOc(x, location.mat, window.mat))\n  adj$context = rownames(location.mat)[adj$context]\n  adj$x = as.factor(colnames(location.mat)[adj$x])\n  adj$y = as.factor(colnames(location.mat)[adj$y])\n  adj\n}\n\n#' Merge a list of matrices\n#' \n#' Merge matrices, by standradizing column and row dimensions and using the Reduce function to merge them.\n#' \n#' @param matrices A list of matrices\n#' @param reduce_func The function to pass to Reduce\n#' @return A single matrix\n#' @export\nmergeMatrices <- function(matrices, reduce_func='+'){\n  rowdim = unique(llply(matrices, function(x) rownames(x)))[[1]]\n  coldim = unique(llply(matrices, function(x) colnames(x)))[[1]]\n  matrices = llply(matrices, function(x) setMatrixDims(x, rowdim, coldim))\n  mat = Reduce(reduce_func, matrices)\n  rownames(mat) = rowdim\n  colnames(mat) = coldim\n  mat\n}\n\nsetMatrixDims <- function(mat, rowdim, coldim){\n  ## set rows and columns of matrix to given rowdim and coldim vectors. (usefull for making different matrices identical so that they can be summed up)  \n  mat = as(mat, 'dgTMatrix')\n  d = data.frame(i=rownames(mat)[mat@i+1], j=colnames(mat)[mat@j+1], v=mat@x) \n  d = d[d$i %in% rowdim & d$j %in% coldim,]\n  d$i = match(d$i, rowdim)\n  d$j = match(d$j, coldim)\n  spMatrix(length(rowdim), length(coldim), d$i, d$j, d$v)\n}\n",
    "created" : 1431977898456.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1548578662",
    "id" : "CC78F59F",
    "lastKnownWriteTime" : 1431977953,
    "path" : "C:/Users/Bob/Dropbox/ICA15/adjacency_functions.R",
    "project_path" : "adjacency_functions.R",
    "properties" : {
        "tempName" : "Untitled1"
    },
    "source_on_save" : false,
    "type" : "r_source"
}